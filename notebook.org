# -*- after-save-hook: org-latex-export-to-pdf; -*-
#+latex_header: \usepackage[margin=2cm]{geometry}
#+latex_header: \usepackage{enumitem}
#+latex_header: \DeclareMathOperator{\sign}{sign}
#+latex_header: \setlength{\parindent}{0cm}

* Linguagens regulares
** Alfabetos
   Um alfabeto é denotado por $\Sigma$. Exemplos:
   #+begin_export latex
   \[
     \Sigma = \{\, 0, 1 \,\} \qquad
     \Sigma = \{\, \text{a}, \text{b}, \text{c}, \text{d}, \text{e} \,\} \qquad
     \Sigma = \{\, \triangle, \text{O}, \square, \text{X} \,\}
   \]
   #+end_export
** Palavras
   Uma palavra (ou cadeia) é uma sequência de zero ou mais símbolos do alfabeto.
   @@latex:\\[5pt]@@
   *Notação*:
   #+begin_export latex
   \begin{align*}
     & \lambda = \varnothing \\
     & 0^4 = 0000 \\
     & \Sigma^3 = \{ 000, 001, 010, 011, 100, 101, 110, 111 \} \\
     & \Sigma^* = \bigcup_{i \in \mathbb{N}} \Sigma^i \quad \text{conjunto de todas as possíveis palavras deste alfabeto.}
   \end{align*}
   #+end_export
   *Concatenação*:
   #+begin_export latex
   \begin{gather*}
     x = 00 \qquad y = 11 \\
     xy = 0011
   \end{gather*}
   #+end_export
   *Reverso*:
   #+begin_export latex
   \[
     (xy)^{\text{R}} = 1100
   \]
   #+end_export
   Observação: uma palavra $w$ é um palíndromo se, e somente se $w^{\text{R}} = w$.
** Linguagens
   Uma linguagem é um conjunto de palavras $L \subseteq \Sigma^*$. @@latex:\\[5pt]@@
   *Operações*:
   #+begin_export latex
   \[ L_1L_2 = \{\, xy \,\mid\, x \in L_1,\, y \in L_2 \,\} \\ \]
   \begin{align*}
     & L^0 = \{\, \lambda \,\} \\
     & L^1 = L \\
     & L^2 = LL \\
     & L^* = \bigcup_{i \in \mathbb{N}} L^i \quad \text{Fecho de Kleene} \\
     & L^+ = \bigcup_{i \in \mathbb{N}^*} L^i \\
     & \varnothing^* = \{\, \lambda \,\} \\
     & \varnothing^+ = \varnothing
   \end{align*}
   #+end_export
   *Teorema*: As linguagens regulares são fechadas sob as seguintes operações
   #+attr_latex: :options [itemsep=0pt]
   - União
   - Interseção
   - Complemento
   - Concatenação
   - Fecho de Kleene
* Autômatos finitos
** Determinísticos
   Um autômato finito determinístico é definido por:
   #+begin_export latex
   \begin{align*}
     & Q && \text{Um conjunto finito de estados.} \\
     & \Sigma && \text{Um alfabeto finito.} \\
     & \delta: Q \times \Sigma \to Q && \text{Uma função de transição.} \\
     & q_o \in Q && \text{Um estado inicial.} \\
     & F \subseteq Q && \text{Um conjunto de estados finais.}
   \end{align*}
   #+end_export
   *Notação*:
   #+begin_export latex
   \begin{align*}
     & L(M) = A \qquad \text{A linguagem reconhecida pelo autômato $M$.} \\[5pt]
     & L(M: F = \varnothing) = \varnothing \\[5pt]
     & \hat{\delta}: Q \times \Sigma^* \to Q \\
     & \hat{\delta}(e, w): \text{aplicação sucessiva de }\delta\text{ aos símbolos de }w.
   \end{align*}
   #+end_export
   Ainda, nos autômatos existe um estado especial, denonimado $\emptyset$, que aprisiona
   todas as transições omitidas.
*** Computação
    Seja $M = (Q,\, \Sigma,\, \delta,\, q_0,\, F)$ um autômato finito determinístico, e $w
    \in \Sigma^*$. \\
    Dizemos que $M$ aceita $w$ se existe uma *sequência* de estados
    $r_1, \,\hdots,\, r_n \in Q$ satisfazendo:
    1. $r_0 = q_0$
    2. $\forall\, i \in [0, n): \delta(r_i,\, w_{i + 1}) = r_{i + 1}$
    3. $r_n \in F$
    Um autômato $M$ reconhece uma linguagem $L$ se $\forall\, w \in L: M \text{ aceita } w$. \\
    Uma linguagem é regular se existe um autômato finito que a reconhece.
*** Minimização de estados
    Dois estados $e$ e $e'$ são *equivalentes* se
    #+begin_export latex
    \[
      \hat{\delta}(e, w) \in F \iff \hat{\delta}(e', w) \in F
    \]
    #+end_export
    O algoritmo de minimização, então, é:
    1. Produza uma partição $P_0 = \{F,\, Q - F\}$ de $Q$, separando os estados finais dos
       não finais.
    2. Para cada bloco de estados $B$ na partição $P_i$, cada símbolo $s$ do
       alfabeto $\Sigma$, e cada par de estados ($e$, $e'$) contidos no bloco B:
       a. Sejam $d = \delta(e, s)$ e $d' = \delta(e' , s)$ os estados para os quais o AFD
          transita quando lê o sı́mbolo $s$ a partir dos estados $e$ e $e'$, respectivamente.
       b. Se $d$ e $d'$ pertencem a blocos diferentes na partiçãoo $P_i$, então
          os estados $e$ e $e'$ não são equivalentes, e devem ser separados na partição
          $P_{i+1}$.
    3. Se a partição $P_{i+1}$ for diferente da partiçãoo $P_i$,
       repita o passo 2.
    4. O autômato mínimo é construído de tal forma que seus estados são os blocos da
       última partição $P$ produzida.
** Não determinísticos
   Um autômato finito não determinístico é definido por:
   #+begin_export latex
   \begin{align*}
     & Q && \text{Um conjunto finito de estados.} \\
     & \Sigma && \text{Um alfabeto finito.} \\
     & \delta: Q \times \Sigma \to \mathcal{P}(Q) && \text{Uma função de transição.} \\
     & I \subseteq Q && \text{Um conjunto de estados iniciais.} \\
     & F \subseteq Q && \text{Um conjunto de estados finais.}
   \end{align*}
   #+end_export
   Sendo $a \in \Sigma$ um símbolo, e $w \in \Sigma^*$ uma palavra, define-se a função de
   transição estendida:
   #+begin_export latex
   \begin{align*}
     & \hat{\delta}: Q \times \Sigma^* \to \mathcal{P}(Q) \\
     & \hat{\delta}(\emptyset,\, w) = \{\emptyset\} \\[5pt]
     & \hat{\delta}(X,\, \lambda) = X \\[5pt]
     & \hat{\delta}(X,\, aw) = \hat{\delta}\left(\,\bigcup_{l \in X} \delta(l,\, a),\, w \right)
   \end{align*}
   #+end_export
   *Teorema*: Todo AFN possui um AFD equivalente. \\
   Por construção:
   #+begin_export latex
   \begin{align*}
     & Q = \mathcal{P}(Q_{\text{afn}}) && \\
     & \Sigma = \Sigma_{\text{afn}} && \\
     & \delta(X, a) = \bigcup_{l \in X} \delta_{\text{afn}}(l,\, a) && \\
     & q_o = I_{\text{afn}} && \\
     & F = \left\{ X \subseteq Q_{\text{afn}} \,\mid\, X \cap F \neq \varnothing \right\}&&
   \end{align*}
   #+end_export
*** Transições $\lambda$
    Um autômato finito não determinístico com transições $\lambda$ introduz a
    possibilidade de transições sem a consumação de símbolos.
    #+begin_export latex
    \begin{align*}
      & Q = Q_{\text{afn}} && \\
      & \Sigma = \Sigma_{\text{afn}} && \\
      & \delta: Q \times \Sigma_{\lambda} \to \mathcal{P}(Q) && \\
      & I = I_{\text{afn}} && \\
      & F = F_{\text{afn}} &&
    \end{align*}
    #+end_export
    Onde $\Sigma_{\lambda} = \Sigma \cup \{\lambda\}$. @@latex:\\[10pt]@@
    Os estados para os quais se transita sem consumir símbolos é definido pelo fecho $\lambda$:
    #+begin_export latex
    \[
      \mathcal{F}_{\lambda}: \mathcal{P}(Q) \to \mathcal{P}(Q)
    \]
    #+end_export
    *Teorema*: O fecho lambda de um estado é pelo menos o próprio estado.
    #+begin_export latex
    \[
      \forall\, X \in Q: X \in \mathcal{F}_{\lambda}(\{X\})
    \]
    #+end_export
    Assim, define-se a função de transição estendida:
    #+begin_export latex
    \begin{align*}
      & \hat{\delta}: Q \times \Sigma_{\lambda}^* \to \mathcal{P}(Q) \\
      & \hat{\delta}(\varnothing, w) = \varnothing \\
      & \hat{\delta}(X, \lambda) = \mathcal{F}_{\lambda}(X) \\
      & \hat{\delta}(X, ay) = \hat{\delta} \left( \bigcup_{Y \in\, \mathcal{F}_{\lambda}(X)} \delta(Y, a),\enspace y \right)
    \end{align*}
    #+end_export
    *Teorema*: Todo AFN$\lambda$ possui um AFN equivalente. \\
    Por construção:
    #+begin_export latex
    \begin{align*}
      & Q = Q_{\text{afn}\lambda} && \\
      & \Sigma = \Sigma_{\text{afn}\lambda} && \\
      & \delta = \mathcal{F}_{\lambda} \circ \delta_{\text{afn}\lambda} && \\
      & I = \mathcal{F}_{\lambda}\left(I_{\text{afn}\lambda}\right) && \\
      & F = F_{\text{afn}\lambda} &&
    \end{align*}
    #+end_export
* Expressões regulares
  Uma expressão regular pode ser uma das seguintes formas, cada qual com a linguagem
  correspondente:
  #+begin_export latex
  \begin{align*}
    & \lambda & \{\lambda\} && \\
    & \varnothing & \varnothing && \\
    & a & \{a\} && \\
    & R_1 + R_2 & L(R_1) \cup L(R_2)  && \\
    & R_1 R_2 & L(R_1) \cdot L(R_2)  && \\
    & R^* & L(R)^* 
  \end{align*}
  #+end_export
  *Operações*:
  #+begin_export latex
  \begin{align*}
    & R^+ = RR^* && \\
    & R^0 = \lambda && \\
    & R^n = RR^{(n - 1)} &&
  \end{align*}
  #+end_export
* Linguagens irregulares
  Nas linguagens regulares, têm se o *lema do bombardeamento*: \\
  Se $L$ é uma linguagem regular, então
  #+begin_export latex
  \begin{align*}
    & \exists\, k \in \mathbb{N}^*: \\
    & \quad \forall\, z \in L, |z| \geq k : \\
    & \quad\quad \exists\, u, v, w: \\
    & \quad\quad\quad 1.\> z = uvw \\
    & \quad\quad\quad 2.\> |uv| \leq k \\
    & \quad\quad\quad 3.\> v \neq \lambda \\
    & \quad\quad\quad 4.\> \forall\,i \in \mathbb{N}^*: \left(uv^iw\right) \in L
  \end{align*}
  #+end_export
  O lema pode ser utilizado para provar que uma dada linguagem não é regular.
* Linguagens livres de contexto
  Uma linguagem livre de contexto é uma linguagem que pode ser denotada por uma gramática
  livre de contexto.
** Gramáticas livres de contexto
   Uma gramática livre de contexto é definida por:
   #+begin_export latex
   \begin{align*}
     & V && \text{Um conjunto finito de variáveis.} \\
     & \Sigma && \text{Um alfabeto finito.} \\
     & R && \text{Um conjunto de regras.} \\
     & S \in V && \text{Uma variável inicial.}
   \end{align*}
   As regras são constituídas da seguinte forma:
   #+end_export
   1. O lado esquerdo de uma regra é constituído por uma única variável.
   2. O lado direito é constituído por uma combinação de terminais e variáveis.
   Por convenção a variável inicial é a variável alvo da primeira regra. \\
   @@latex:\\@@
   Exemplo:
   #+begin_export latex
   \begin{align*}
     G = \big(\{A, B\}, & \, \{0, 1, 5\},\, R,\, A \big) \\
     R: \quad & A \to 0A1 \\
              & A \to B \\
              & B \to 5
   \end{align*}
   #+end_export
